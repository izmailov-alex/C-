Вещественным числом считается число типа double. Необходимо реализовать вещественную матрицу –
понятие линейной алгебры. Нужно обеспечить пользователя класса естественным интерфейсом
математических операций для работы с матрицами и составления вычислительных программ.
Для удобства тестирования и отладки ввести строковое представление матрицы, похожее на инициализатор
двумерного массива. Так, строка "{{1, 0, 0}, {0, 1, 0.5}}" обозначает матрицу размера 2 ́3:
1  0  0
0  1  0.5

Операции:
1) matrix( int n, int m ) – конструктор матрицы размера n ́m со значениями 0.0;
2) matrix( double ) – матрица 1 ́1 с этим элементом;
3) matrix( double*, int m ) – матрица-строка из массива длины m;
4) matrix( int n, double* ) – матрица-столбец из массива длины n;
5) matrix( char*) – из строкового представления (см. выше);
6) static matrix matrix::identity( int n ) – возвращает единичную матрицу размера n;
7) static matrixmatrix::diagonal( double* vals, int n ) – возвращает диагональную матрицу размера n с заданными
элементами по главной диагонали;
8) int matrix::rows() – число строк;
9) int matrix::columns() – число столбцов;
10) matrix::set( int i, int j, double val ) – присвоить значение элементу [i][j];
11) matrix matrix::matrix[ i ] – i-я строка в виде новой матрицы, если такая строка есть – 1-й приоритет
12) matrix matrix::matrix[ j ] – j-й столбец в виде новой матрицы, если такой столбец есть – 2-й приоритет, –
иначе ошибка (если M – матрица, то M[i] –матрица из одной строки, а М[i][j] – матрица 1 ́1 из одного элемента);
13) matrix * scalar и matrix*=scalar – умножение матрицы на скаляр;
14) перегрузка операции << – вывод матрицы, в привычном двумерном виде.
15) matrix + matrix ;
16) matrix += matrix ;
17) matrix - matrix ;
18) matrix -= matrix ;
19) matrix * matrix ;
20) matrix *= matrix ;
21) -matrix – унарный минус, применить ко всем элементам ;
22) matrix == matrix – точность сравнения задана статической константой matrix::EPS ;
23) matrix != matrix ;
24) matrix | matrix – конкатенировать (приписать) матрицы горизонтально (вторую справа от первой);
25) matrix / matrix – конкатенировать (приписать) матрицы вертикально (вторую под первой).
26) ~matrix – обратная матрица;
27) double matrix::determinant() – определитель;
28) matrix matrix::solve() – решить любым способом неоднородную систему из n линейных алгебраических
уравнений с n неизвестными, представленную матрицей размера n ́(n+1); вернуть решение в виде матрицы 1 ́n;
выбросить исключение в случае неразрешимости системы (с учетом EPS); обязательно зафиксируйте ошибку,
например: x = (A | b).solve(); if( A*x != b ) error( "solve" );
29) эффективная реализация индексирования – обеспечение возможности присваивания m[i][j] =
вещественное_значение; (для реализации понадобится внутренний класс-адаптер «Строка_матрицы» с
внутренним полем-ссылкой на «настоящую» строку матрицы).

Программы:
Matrix.h - Описание класса Matrix, всех методов и подклассов
Matrix.cpp - Реализация всех методов класcа Matrix
Main.cpp - Файл с тестами всех методов класса


Функции:
class matrix{
    //внутренний класс строк
    class lines{
        public:
            double *line; // указатель на строку
            int change; // номер элемента в строке который нужно изменить
            lines(); // конструктор 
            void set(double *str); // метод устанавливающий ссылку на строку
            ~lines(); //деструктор
    };
    double **matr; // матрица
    int str; // количество строк матрицы
    int col; // количество столбцов матрицы
    lines *strings; // массив строк матрицы
public:
    //внутренний класс ошибок
    class errors{
        public:
            char s[100] = {0,}; //строка ошибки
            errors(char *str); //конструктор ошибки
    };
    matrix(int n, int m); // конструктор матрицы размером n m со значениями 0.0 
    matrix(char *ch); // конструктор матрицы из строкового представления {{1,2,3},{4,5,6}}
    matrix(double ch); //  матрица 1 ́1 с этим элементом;
    matrix(double *ch, int m); //матрица-строка из массива длины m;
    matrix(int n, double *ch); // матрица-столбец из массива длины n;
    static matrix identity(int n); // возвращает единичную матрицу размера n;
    static matrix diagonal(double *ch, int n); // возвращает диагональную матрицу размера n с заданными элементами по главной диагонали;
    int rows(); // возвращает число строк;
    int columns(); // возвращает число столбцов
    friend ostream& operator<<(ostream& out, const matrix &m); //функция перегрузки оператора <<
    int set(int i, int j, double val); //  присвоить значение элементу m[i][j];
    matrix operator+(const matrix& mt); // перегрузка оператора +
    matrix& operator+=(const matrix& mt); // перегрузка оператора +=
    double operator!(); //перегрузка оператора !, который считает след матрицы
    int gaus(); // Функция приводящая методов гауса матрицу к верхнетреугольной форме
    matrix operator~(); // перегрузка оператора ~, которая находит обратную матрицу
    matrix solve(matrix *n); // функция решающая неоднородное слау методом гауса
    const double determinant(); // функция считающая определитель матрицы
    matrix operator-(const matrix& mt); // перегрузка оператора -
    matrix& operator-=(const matrix& mt); // перегрузка оператора -=
    matrix operator*(const matrix& mt); // перегрузка оператора *
    matrix& operator-(); // перегрузка оператора унарный -
    matrix& operator*=(const matrix& mt); // перегрузка оператора *=
    int operator==(matrix &m); // перегрузка оператора ==, сравнивающая матрицы
    int operator!=(matrix &m); // перегрузка оператора !=
    matrix operator[](const int i); //перегрузка оператора []
    matrix& operator|(const matrix &m); // перегрузка оператора |
    matrix& operator/(const matrix &m); // перегрузка оператора /
    matrix& operator=(const matrix &m); // перегрузка оператора =, который присваивает матрицы
    void operator=(double n); // перегрузка оператора =, который меняет элемент в матрице
    matrix operator*(const int scal); // перегрузка оператора *, который умножает матрицу на число 
    matrix& operator*=(const int scal); // перегрузка оператора *=, который умножает матрицу на число и присваивает значение новой
    ~matrix(); //деструктор матриц
};